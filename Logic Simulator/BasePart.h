#pragma once
#include "stdafx.h"

// Base class for every part. Introduces methods which every derived part needs to implement
class BasePart : public Identifiable, public IEventSubscriber<>
{
protected:

	#pragma region Members

	// String which will be presented to the user as this part's name
	std::string mPrintName = "Base Part";
	
	#pragma endregion

	#pragma region Virtual Methods	

	// Abstract method which computes and assignes value to output(s)
	virtual void ComputeOutput() = 0;

	// Initial routine unique to each part
	virtual void InitializeRoutine() = 0;

	// Assigns ownership to every output socket, should be overriden by every derived class that has at least one output socket
	virtual void AssignOwnership() {}

	#pragma endregion

	#pragma region Constructor

	// Default constructor
	BasePart() { }

	#pragma endregion

public:

	#pragma region Accessors

	// Returns the number of selectable lines in this part's info section
	virtual int SelectableLines() = 0;

	// Getter to the PrintName of this part
	std::string PrintName() { return mPrintName; }

	#pragma endregion

	#pragma region Methods

	// Can be used to assign this part's ID and the socket's ID to a given Node
	void AssignNodeOwnership(std::shared_ptr<Node> node, std::shared_ptr<OutputSocket> socket);

	// Performs actions necessary when creating an object (called when object is created through BasePart::Create)
	// Assigns ownership of output nodes and performs InitializeRoutine unique to each derived class
	void Initialize();

	// Method which calls PrintManagerStatus. If an input socket doesn't warrant a change in output but
	// the statuses need to be refreshed then this method can be used as a callback
	void RefreshInfoStatus();

	#pragma endregion

	#pragma region Virtual Methods

	// Returns a list with lines that compose a full info on this part.
	// Should be overriden to include info about the inherited class.
	virtual std::list<Line> GenerateInfo();

	// Returns status lines for the part which has the same structure as list generated by GenerateInfo.
	// All lines that don't carry information about status are empty
	virtual std::list<Line> GenerateStatus();

	// Method called whenever one of the inputs changes its value. Base version calls ComputeOutput
	// and PrintManagerStatus(PartInfo | PartList)
	virtual void InputChanged();

	// Prints the compact information on this part (dedicated to the list of parts)
	// Printed informations is: "*PrintName*, ID: 5". Can (and should) be overriden
	// to provide more specific information
	virtual void PrintList();

	// Performs quick action for the given line (if there's an action to perform)
	virtual void QuickActionRequest(int index) { }

	// Performs quick list action (if there's an action to perform)
	virtual void QuickListActionRequest() { }

	// Generates a vector of strings to save in a file which allows to recreate this part
	// First element is information about input connections
	// Second is the code of the part
	// Third are specific settings of the part (for example a period of a clock)
	virtual std::vector<std::string> GenerateStorageString() = 0;

	// Interprets a storage string and assigns the settings saved in it. Modifies connections by substituting old (assigned
	// when the custom logic was saved) IDs with new ones (assigned when the custom logic is loaded)
	virtual void InterpretStorageString(std::string settings, std::list<std::pair<int, int>>& connections) = 0;

	#pragma endregion

	#pragma region Constructors/Destructors

	// Default Destructor
	virtual ~BasePart() { }

	#pragma endregion

	#pragma region Factory

	// Creates a new shared_ptr of T with already assigned ID
	// and returns it. If T does not derive from BasePart, throws an exception.
	// CtorArgs - arguments to pass to the object's constructor
	template<typename T, typename... CtorArgs>
	static std::shared_ptr<T> Create(CtorArgs... args)
	{
		std::shared_ptr<T> newObject = Identifiable::Create<T>(args...);

		if (std::shared_ptr<BasePart> casted = std::dynamic_pointer_cast<BasePart>(newObject))
		{
			// If we could cast the type T to Identifiable, assign it an ID
			newObject->Initialize();

			return newObject;
		}
		else
		{
			throw std::exception("Type to create does not derive from BasePart");
		}
	}

	#pragma endregion
};