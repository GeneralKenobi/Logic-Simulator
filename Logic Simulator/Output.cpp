#include "stdafx.h"

#define SELECTABLE_LINES 10


void Output::InitializeRoutine()
{
	mInput->InternalStateChanged.Subscribe(std::dynamic_pointer_cast<IEventSubscriber>(shared_from_this()),
		std::bind(&BasePart::InputChanged, this));
}

// Default Constructor
Output::Output()
{
	mPrintName = "Output";
}


// Returns a list with lines that compse a full info on this part.
// String is the line to print, int is the indentation (x offset) of the line
// Should be overriden to include info about the inherited class.
std::list<Line> Output::GenerateInfo()
{
	std::list<Line> l = BasePart::GenerateInfo();
	l.push_back(Line("(QA) Custom logic output", 0, 0, 30, mIsCustomLogicOutput ? NORMAL_COLOR : GRAY));
	l.push_back(Line());

	l.push_back(Line("Input socket:"));
	l.push_back(Line());
	l.splice(l.end(), mInput->GenerateInfo());



	return l;
}

// Returns status lines for the part which has the same structure as list generated by GenerateInfo.
// All lines that don't carry information about status are empty
std::list<Line> Output::GenerateStatus()
{
	std::list<Line> l = BasePart::GenerateStatus();

	l.push_back(Line());
	l.push_back(Line());
	l.push_back(Line());
	l.push_back(Line());
	l.push_back(Line());
	l.splice(l.end(), mInput->GenerateStatus());
	
	return l;
}

// Prints the compact information on this part (dedicated to the list of parts)
void Output::PrintList()
{
	BasePart::PrintList();
	PrintStatus(mInput->Value());
}

// Returns the numberof selectable lines in this part's info
int Output::SelectableLines()
{
	return SELECTABLE_LINES;
}


// Covers indexes 0-6
// Performs quick action for the given line (if there's an action to perform)
void Output::QuickActionRequest(int index)
{
	switch (index)
	{
		case 0:
		case 1:
		case 2:
		{
			BasePart::QuickActionRequest(index);
		}
		break;

		case 8:
		{
			mInput->QuickAction();
		}
		break;

		case 3:
		{
			mIsCustomLogicOutput = !mIsCustomLogicOutput;
			PrintManager(Sector::PartInfo);
		} break;
	}
}


// Generates string to save in a file which allows to recreate this part
// If it's a custom logic output it generates:
// input connection
// CUSTOM_LOGIC_PORT code
// 1; ID; mInputID
// If it's not it returns an empty string indicating that it shouldn't be saved as it doesn't affect the circuit
std::vector<std::string> Output::GenerateStorageString()
{
	if (!mIsCustomLogicOutput)
	{
		return std::vector<std::string>();
	}

	std::string firstPart = std::to_string(CUSTOM_LOGIC_PORT);

	std::string secondPart = std::to_string(2) + ";" + std::to_string(-ID()) + ";" + std::to_string(-mInput->ID());

	std::string thirdPart;

	if (mInput->IsConnected())
	{
		thirdPart = std::to_string(-mInput->ID()) + "," + std::to_string(-mInput->ConnectedSocketID());
	}

	return std::vector<std::string> {thirdPart, firstPart, secondPart};
}

void Output::InterpretStorageString(std::string settings, std::list<std::pair<int, int>>& connections)
{

}
