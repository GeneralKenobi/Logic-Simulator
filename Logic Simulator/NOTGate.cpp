#include "stdafx.h"

#define PRINTABLE_LINES 15


// Default constructor
NOTGate::NOTGate()
{
	mPrintName = "NOT Gate";
}


// Returns the number of selectable lines in this part's info
int NOTGate::SelectableLines()
{
	return PRINTABLE_LINES;
}


// Returns a list with lines that compse a full info on this part.
// String is the line to print, int is the indentation (x offset) of the line
// Should be overriden to include info about the inherited class.
std::list<Line> NOTGate::GenerateInfo()
{
	// Standard information
	std::list<Line> l = BasePart::GenerateInfo();

	// Output header
	l.push_back(Line("Output:"));
	l.push_back(Line());

	// Information about the output socket
	l.splice(l.end(), mOutput->GenerateInfo());
	l.push_back(Line());

	// Output header
	l.push_back(Line("Input:"));
	l.push_back(Line());

	// Information about input socket
	l.splice(l.end(), mInput->GenerateInfo());
	l.push_back(Line());

	return l;
}


// Returns status lines for the part which has the same structure as list generated by GenerateInfo.
// All lines that don't carry information about status are empty
std::list<Line> NOTGate::GenerateStatus()
{
	std::list<Line> l = BasePart::GenerateStatus();

	// Output header
	l.push_back(Line());
	l.push_back(Line());

	// Information about the output socket
	l.splice(l.end(), mOutput->GenerateStatus());
	l.push_back(Line());

	// Output header
	l.push_back(Line());
	l.push_back(Line());

	// Information about input socket
	l.splice(l.end(), mInput->GenerateStatus());
	l.push_back(Line());

	return l;
}


// Prints the information about this part for list of parts
void NOTGate::PrintList()
{
	BasePart::PrintList();
	PrintStatus(mOutput->Value());
}


// Assigns ownership of output socket to this particular object
void NOTGate::AssignOwnership()
{
	AssignNodeOwnership(mOutput->mAssignedNode, mOutput);
}


// Performs quick action for the given line (if there's an action to perform)

void NOTGate::QuickActionRequest(int index)
{
	switch (index)
	{
		case 0:
		case 1:
		case 2:
		{
			BasePart::QuickActionRequest(index);
		}
		break;

		case 6:
		{
			mOutput->QuickAction();
		}
		break;

		case 12:
		{
			mInput->QuickAction();			
		}
		break;
	}
}

std::vector<std::string> NOTGate::GenerateStorageString()
{
	std::string firstPart = std::to_string(NOT_GATE);

	std::string secondPart = std::to_string(-ID()) + ";" + std::to_string(-mInput->ID()) + ";" +
		std::to_string(-mOutput->ID());

	std::string thirdPart = mInput->GenerateConnectionString();

	return std::vector<std::string> {thirdPart, firstPart, secondPart};
}



void NOTGate::InterpretStorageString(std::string settings, std::list<std::pair<int, int>>& connections)
{
	auto v = Split(settings, ';');

	int oldID = std::stoi(v[0]);
	int oldInputID = std::stoi(v[1]);
	int oldOutputID = std::stoi(v[2]);

	SwapID(connections, oldID, ID());
	SwapID(connections, oldInputID, mInput->ID());
	SwapID(connections, oldOutputID, mOutput->ID());

}

// Method which is resposnible for computing this part's value. Negates the input
void NOTGate::ComputeOutput()
{
	bool newValue = !mInput->Value();

	if (newValue != mOutput->Value())
	{
		mOutput->Value(newValue);
		PrintManagerStatus(Sector::PartList, ID());
	}
}


// Subscribes to mInput's InternalStateChangedEvent, assigns node ownership
void NOTGate::InitializeRoutine()
{
	// Subscribe to the InternalStateChanged event
	mInput->InternalStateChanged.Subscribe(
		std::dynamic_pointer_cast<IEventSubscriber>(shared_from_this()),
		std::bind(&BasePart::InputChanged, this));
}


