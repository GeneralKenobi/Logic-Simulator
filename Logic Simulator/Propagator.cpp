#include "stdafx.h"



// Computes and assignes output value (propagates input)
void Propagator::ComputeOutput()
{
	mOutput->Value(mInput->Value());
}


// Method performing initial routine for each part
// Subscribes to the InternalStateChanged event of the input
void Propagator::InitializeRoutine()
{
	mInput->InternalStateChanged.Subscribe(std::dynamic_pointer_cast<IEventSubscriber>(shared_from_this()),
		std::bind(&Propagator::InputChanged, this));
}

void Propagator::AssignOwnership()
{
 AssignNodeOwnership(mOutput->mAssignedNode, mOutput);
}


void Propagator::InputChanged()
{
	ComputeOutput();
	PrintManagerStatus(Sector::PartInfo, mOutput->mAssignedNode->OwnerID());
}

// Default constructor
Propagator::Propagator()
{
	mPrintName = "Output";
}


int Propagator::SelectableLines()
{
	return 20;
}

// Returns a list with lines that compose a full info on this part.
// Should be overriden to include info about the inherited class.
std::list<Line> Propagator::GenerateInfo()
{
	std::list<Line> l;

	if (mOperationMode==2)
	{
		l.splice(l.end(), mOutput->GenerateInfo());
	}
	else
	{
		l.splice(l.end(), mInput->GenerateInfo());
	}
	
	return l;
}

// Returns status lines for the part which has the same structure as list generated by GenerateInfo.
// All lines that don't carry information about status are empty
std::list<Line> Propagator::GenerateStatus()
{
	std::list<Line> l;

	if (mOperationMode==2)
	{
		l.splice(l.end(), mOutput->GenerateStatus());
	}
	else
	{
		l.splice(l.end(), mInput->GenerateStatus());
	}


	return l;
}


// Prints the compact information on this part (dedicated to the list of parts)
// Printed informations is: "*PrintName*, ID: 5". Can (and should) be overriden
// to provide more specific information
void Propagator::PrintList()
{
	BasePart::PrintList();
	PrintStatus(mOutput->Value());
}


// Quickaction for a custom logic port is simply quick action of either input or output socket, depending on the
// role of the given port
void Propagator::QuickActionRequest(int index)
{
	if (mOperationMode==2)
	{
		mOutput->QuickAction();
	}
	else
	{
		mInput->QuickAction();
	}
}


void Propagator::InterpretStorageString(std::string settings, std::list<std::pair<int, int>>& connections)
{
	auto v = Split(settings, ';');

	mOperationMode = std::stoi(v[0]);

	int oldID = std::stoi(v[1]);
	int oldSocketID = std::stoi(v[2]);

	SwapID(connections, oldID, ID());
	if (v.size() > 3)
	{
		SwapID(connections, oldSocketID, mInput->ID());
		SwapID(connections, std::stoi(v[3]), mOutput->ID());
	}
	else
	{
		SwapID(connections, oldSocketID, mOperationMode==1 ? mOutput->ID() : mInput->ID());
	}
}

std::vector<std::string> Propagator::GenerateStorageString()
{
	std::string firstPart = std::to_string(CUSTOM_LOGIC_PORT);

	std::string secondPart = std::to_string(0) + ";" + std::to_string(-ID()) + ";" + std::to_string(-mInput->ID()) + ";" +
		std::to_string(-mOutput->ID());

	std::string thirdPart = mInput->GenerateConnectionString();

	return std::vector<std::string> {thirdPart, firstPart, secondPart};
}
