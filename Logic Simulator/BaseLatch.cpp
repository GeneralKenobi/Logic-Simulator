#include "stdafx.h"


#define SELECTABLE_LINES 36



// Sets the value to mQ and negated value to mQComplement. Calls PrintManagerStatus
void BaseLatch::SetOutput(bool value)
{	
	value = AdjustForAsyncInputs(value);

	mQ->Value(value);
	mQComplement->Value(!value);

	PrintManagerStatus(Sector::PartList | Sector::PartInfo, ID());
}


// Returns a value adjusted for the state of asynchronous inputs
bool BaseLatch::AdjustForAsyncInputs(bool value)
{
	return (mNegateStraw^mStraw->Value()) && ((value && !mReset->Value()) || (mDominantSet && mSet->Value() ||
		mSet->Value() && !mReset->Value()));
}


// Assigns ownership to outputs
void BaseLatch::AssignOwnership()
{
	AssignNodeOwnership(mQ->mAssignedNode, mQ);
	AssignNodeOwnership(mQComplement->mAssignedNode, mQComplement);
}


// Method performing initial routine for each part
void BaseLatch::InitializeRoutine()
{
	// Subscribe to asynchronous inputs' internal state changed events

	mSet->InternalStateChanged.Subscribe(std::dynamic_pointer_cast<IEventSubscriber>(shared_from_this()),
		std::bind(&BaseLatch::AsyncInputChanged, this));

	mReset->InternalStateChanged.Subscribe(std::dynamic_pointer_cast<IEventSubscriber>(shared_from_this()),
		std::bind(&BaseLatch::AsyncInputChanged, this));

	// Subscribe to mClock and mStraw internal state changed to refresh the info page if they change their state

	mClock->InternalStateChanged.Subscribe(std::dynamic_pointer_cast<IEventSubscriber>(shared_from_this()),
		std::bind(&BasePart::RefreshInfoStatus, this));

	mStraw->InternalStateChanged.Subscribe(std::dynamic_pointer_cast<IEventSubscriber>(shared_from_this()),
		std::bind(&BasePart::RefreshInfoStatus, this));

	// Set the complemented output to true
	mQComplement->Value(true);
}


// Returns a list with lines that compose a full info on this part.
std::list<Line> BaseLatch::GenerateInfo()
{
	std::list<Line> l = BasePart::GenerateInfo();
	l.push_back(Line("(QA) Use negative clock", 0, 0, 30, mUseNegativeClock ? NORMAL_COLOR : GRAY));
	l.push_back(Line("(QA) Negate straw", 0, 0, 30, mNegateStraw ? NORMAL_COLOR : GRAY));
	l.push_back(Line("(QA) Dominant set", 0, 0, 30, mDominantSet ? NORMAL_COLOR : GRAY));
	l.push_back(Line());

	l.push_back(Line("Clock"));
	l.splice(l.end(), mClock->GenerateInfo());
	l.push_back(Line());

	l.push_back(Line("Straw"));
	l.splice(l.end(), mStraw->GenerateInfo());
	l.push_back(Line());

	l.push_back(Line("Asynchronous set"));
	l.splice(l.end(), mSet->GenerateInfo());
	l.push_back(Line());

	l.push_back(Line("Asynchronous reset"));
	l.splice(l.end(), mReset->GenerateInfo());
	l.push_back(Line());

	l.push_back(Line("Q output"));
	l.splice(l.end(), mQ->GenerateInfo());
	l.push_back(Line());

	l.push_back(Line("~Q output"));
	l.splice(l.end(), mQComplement->GenerateInfo());

	return l;
}


// Returns status lines for the part which has the same structure as list generated by GenerateInfo.
// All lines that don't carry information about status are empty
std::list<Line> BaseLatch::GenerateStatus()
{
	std::list<Line> l = BasePart::GenerateStatus();
	l.push_back(Line());
	l.push_back(Line());
	l.push_back(Line());
	l.push_back(Line());	

	l.push_back(Line());
	l.splice(l.end(), mClock->GenerateStatus());
	l.push_back(Line());

	l.push_back(Line());
	l.splice(l.end(), mStraw->GenerateStatus());
	l.push_back(Line());

	l.push_back(Line());
	l.splice(l.end(), mSet->GenerateStatus());
	l.push_back(Line());

	l.push_back(Line());
	l.splice(l.end(), mReset->GenerateStatus());
	l.push_back(Line());

	l.push_back(Line());
	l.splice(l.end(), mQ->GenerateStatus());
	l.push_back(Line());

	l.push_back(Line());
	l.splice(l.end(), mQComplement->GenerateStatus());

	return l;
}


// Prints the compact information on this part (dedicated to the list of parts)
void BaseLatch::PrintList()
{
	BasePart::PrintList();

	PrintStatus(mQ->Value());
}


// Performs quick action for the given line (if there's an action to perform)
void BaseLatch::QuickActionRequest(int index)
{
	switch (index)
	{
		case 0:
		case 1:
		case 2:
		{
			BasePart::QuickActionRequest(index);
		}

		// Toggle use negative clock
		case 3:
		{
			mUseNegativeClock = !mUseNegativeClock;
			PrintManager(Sector::PartInfo);
		}
		break;

		// Toggle Negate straw bool
		case 4:
		{
			mNegateStraw = !mNegateStraw;

			// If the part is now turned off, reset the output
			if (!(mNegateStraw ^ mStraw->Value()))
			{
				SetOutput(false);
			}

			PrintManager(Sector::PartInfo);
		}
		break;

		// Toggle mDominantSet bool
		case 5:
		{
			mDominantSet = !mDominantSet;
			PrintManager(Sector::PartInfo);
		}
		break;

		// Clock quick action
		case 9:
		{
			mClock->QuickAction();
		}
		break;

		// Straw quick action
		case 14:
		{
			mStraw->QuickAction();
		}
		break;

		// Asynchronous Set quick action
		case 19:
		{
			mSet->QuickAction();
		}
		break;

		// Asynchronous Reset quick action
		case 24:
		{
			mReset->QuickAction();
		}
		break;

		// Q quick action
		case 29:
		{
			mQ->QuickAction();
		}
		break;

		// Q complemented quick action
		case 34:
		{
			mQComplement->QuickAction();
		}
		break;
	}
}


// Generates string to save in a file which allows to recreate this part
// ID; mClockID; mSetID; mResetID; mQID; mQComplementID; mStrawID; mNegateStraw; mDominantSet; mUseNegativeClock
// mClockConnection; mSetConnection; mResetConnection; mStrawConnection
std::pair<std::string, std::string> BaseLatch::GenerateStorageSecondThird()
{
	std::string secondPart = std::to_string(-ID()) + ";" + std::to_string(-mClock->ID()) + ";" +
		std::to_string(-mSet->ID()) + ";" +std::to_string(-mReset->ID()) + ";" + std::to_string(-mQ->ID()) + ";" +
		std::to_string(-mQComplement->ID()) + ";" + std::to_string(-mStraw->ID()) + ";" + std::to_string(mNegateStraw) + ";" +
		std::to_string(mDominantSet) + ";" + std::to_string(mUseNegativeClock);

	std::string thirdPart = mClock->GenerateConnectionString() + mSet->GenerateConnectionString() +
		mReset->GenerateConnectionString() + mStraw->GenerateConnectionString();

	return std::make_pair(secondPart, thirdPart);
}



// Applies settings given in the vector
void BaseLatch::ApplySettings(std::vector<std::string> info, std::list<std::pair<int, int>>& connections)
{
	std::vector<int> ids;

	try
	{
		// Cast every string to an int
		for (int i = 0; i < 10; ++i)
		{
			ids.push_back(std::stoi(info[i]));
		}
	}
	catch(std::exception e)
	{
		throw Exception("Data is corrupted");
	}

	// Swap the old ids for new ones
	SwapID(connections, ids[0], ID());
	SwapID(connections, ids[1], mClock->ID());
	SwapID(connections, ids[2], mSet->ID());
	SwapID(connections, ids[3], mReset->ID());
	SwapID(connections, ids[4], mQ->ID());
	SwapID(connections, ids[5], mQComplement->ID());
	SwapID(connections, ids[6], mStraw->ID());

	// Assign the settings
	mNegateStraw = (bool)ids[7];
	mDominantSet = (bool)ids[8];
	mUseNegativeClock = (bool)ids[9];
}


// Returns the numberof selectable lines in this part's info
int BaseLatch::SelectableLines()
{
	return SELECTABLE_LINES;
}


// Handles changes in mSet and mReset inputs
void BaseLatch::AsyncInputChanged()
{
	if (mNegateStraw ^ mStraw->Value())
	{
		// Formula obtained by hand, Qnext = Q*~Reset + DomSet*Set + Set*~Reset
		SetOutput((mQ->Value() && !mReset->Value()) || (mDominantSet && mSet->Value()) || (mSet->Value() && !mReset->Value()));
	}
	else
	{
		PrintManagerStatus(Sector::PartList | Sector::PartInfo, ID());
	}
}
